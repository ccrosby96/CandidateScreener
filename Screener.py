import requests
from io import StringIO
import key 
import json
import time
import pandas as pd
import sqlite3
import smtplib
from datetime import datetime
from dbInterface import dbInterface
from messenger import Messenger,Person

api_token = key.key
sector = "Healthcare"
industry = "Biotechnology"

class Screener():
    def __init__(self,sector = "Healthcare",loss = 10,industry = "Biotechnology",min_marketcap = 100000000,key = api_token) -> None:
        self.session = requests.Session()
        self.sector_filter = str(sector)
        self.industry_filter = str(industry)
        self.min_marketcap = str(min_marketcap)
        self.exchange_filter = "US"
        self.loss_p_filter = loss*-1
        self.desiredImplVol = 50
        self.key = key
        self.field_dict = {"sector":self.sector_filter,"industry":self.industry_filter,"exchange":self.exchange_filter,
        "market_capitalization":self.min_marketcap, "refund_5d_p":self.loss_p_filter}
        self.signal_dict = {}
        self.base_url = "https://eodhistoricaldata.com/api/screener?api_token={}&sort=refund_5d_p.asc&filters=".format(self.key)

    def generate_filter_string(self):
        s = self.base_url
        f = ""
        l = len(self.field_dict)
        num = 1
        for field, value in self.field_dict.items():
            if field == "refund_1d_p" or field == "refund_5d_p":
                i = '["{0}","<=","{1}"]{2}'.format(field,value,'' if num==l else ",")
                num+=1
                f+=i
            elif field == "market_capitalization":
                i = '["{0}",">=","{1}"]{2}'.format(field,value,'' if num==l else ",")
                num+=1
                f+=i
            else:
                i = '["{0}","=","{1}"]{2}'.format(field,value,'' if num==l else ",") 
                num+=1
                f+=i
        return s+"[{0}]".format(f) + "&limit=100"
    def get_candidates(self):
        '''This method makes a call to the eod API using a string generated by
            the generate_filter_string method. A json object is returned containg data
            on all potential companies that passed the screening parameters'''
        if self.session is None:
            self.session = requests.Session()
        url = self.generate_filter_string()
        
        r = self.session.get(url)
        if r.status_code == requests.codes.ok:

            json_data = json.loads(r.text)
            return json_data
        else:
            raise Exception(r.status_code, r.reason, url)
    
    def extract_tickers(self):
        '''This method extracts the ticker symbols from the JSON object response from the eod API. It then 
            stores them in the candidates.txt file'''
        tickers = []
        with open('candidates.txt') as json_file:
            data = json.load(json_file)
            for p in data['data']:
                tickers.append(p["code"])
        return tickers
    def get_tickers(self):
        '''This method  extracts the ticker symbols from the JSON object response from the eod API. A list
            of them is then returned. No write operations are made with this method'''
        tickers = []
        #API called here
        data = self.get_candidates()
        for ticker in data['data']:
            tickers.append((ticker["code"],ticker["name"]))
        return tickers
    # A test method for option calls to the eod API with Apple ticker
    def get_option_test(self):
        url = "https://eodhistoricaldata.com/api/options/AAPL.US?api_token={}".format(self.key)
        if self.session is None:
            self.session = requests.Session()
        res = self.session.get(url)
        if res.status_code == requests.codes.ok:
            json_data = json.loads(res.text)
            with open('options.txt', 'w') as outfile:
                json.dump(json_data,outfile)
    def get_option_data(self,tickers):
        '''get_option_data takes in a list of tuples, each containing
            a ticker and respective company name. It then makes a call
            to the eod API and determines if options exist that would be 
            favorable for the buy/write strategy. Those that do are appended
            to a list and are then returned.'''

        reviewed_candidates = []
        if self.session is None:
            self.session = requests.Session()

        #for ticker in self.get_tickers():
        for ticker in tickers:
            option_url = "https://eodhistoricaldata.com/api/options/{0}?api_token={1}".format(ticker[0] + ".US",self.key)
            print(option_url)
            r = self.session.get(option_url)
            if r.status_code == requests.codes.ok:
                json_data = json.loads(r.text)
                if self.check_option_factors(json_data):
                    reviewed_candidates.append(ticker)
            time.sleep(0.005)
        return reviewed_candidates


    def check_option_factors(self,json_object):
        '''This method returns a boolean indicating if a particular ticker has options suitable for 
            for the buy write strategy. '''
        obj = json_object
        # We need to see if option data exists for this candidate. If not, then a buy write can't be constructed
        if not obj.get('data'):
            return False
        for dates in obj['data']:
            # Examine the Call options 
            for call in dates['options']['CALL']:
                if call['inTheMoney'] == "FALSE" and float(call['impliedVolatility']) > self.desiredImplVol:
                    return True
        return False

def main():
    #Getting the Current Date in YYYY-MM-DD format
    curr_date = datetime.today().strftime("%Y-%m-%d")
    print(key.key)
    #Screener Object
    screener = Screener(sector,30)
    #Wrapper object for Sqlite database
    db = dbInterface()
    #Messenger object for pushing out findings
    messenger = Messenger()

    print(screener.generate_filter_string())
    print('\n')
    ticker_list = screener.get_tickers()
    for ticker in ticker_list:
        # Check to see if this ticker is on hold and scrub it from list if so
        if db.check_for_hold(ticker[0]):
            ticker_list.remove(ticker)
    
    #Further filter by checking to see if candidates have options sufficient for buy/write strategy
    candidates = screener.get_option_data(ticker_list)

    #Insert candidates into the ticker table. A trigger will place these in the hold_list table 
    #automatically.
    #db.insert_ticker(candidates)

    #Message to be pushed to mailing list
    if candidates:
        tape = messenger.generate_message(candidates)

        for row in db.fetch_data("SELECT first_name,last_name,phone_number,carrier_id FROM mail_list WHERE first_name = 'Calvin' "):
            carrier = db.con.execute('SELECT name FROM carrier WHERE carrier_id = ?',(row[-1],)).fetchone()[0]
            person = Person(row[0],row[1],row[2],carrier)
            messenger.send(person,tape)

        print("Vetted candidates: " + str(candidates))

    db.scrub_hold_list()
        
    
if __name__ == "__main__":
    main()
